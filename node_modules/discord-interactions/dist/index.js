"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyKeyMiddleware = exports.verifyKey = exports.InteractionResponseFlags = exports.InteractionResponseType = exports.InteractionType = void 0;
const nacl = require('tweetnacl');
// Use built-in TextEncoder if available, otherwise import from node util.
const LocalTextEncoder = typeof TextEncoder === 'undefined' ? require('util').TextEncoder : TextEncoder;
/**
 * The type of interaction this request is.
 */
var InteractionType;
(function (InteractionType) {
    /**
     * A ping.
     */
    InteractionType[InteractionType["PING"] = 1] = "PING";
    /**
     * A command invocation.
     */
    InteractionType[InteractionType["APPLICATION_COMMAND"] = 2] = "APPLICATION_COMMAND";
    /**
     * Usage of a message's component.
     */
    InteractionType[InteractionType["MESSAGE_COMPONENT"] = 3] = "MESSAGE_COMPONENT";
    /**
     * An interaction sent when an application command option is filled out.
     */
    InteractionType[InteractionType["APPLICATION_COMMAND_AUTOCOMPLETE"] = 4] = "APPLICATION_COMMAND_AUTOCOMPLETE";
})(InteractionType || (InteractionType = {}));
exports.InteractionType = InteractionType;
/**
 * The type of response that is being sent.
 */
var InteractionResponseType;
(function (InteractionResponseType) {
    /**
     * Acknowledge a `PING`.
     */
    InteractionResponseType[InteractionResponseType["PONG"] = 1] = "PONG";
    /**
     * Respond with a message, showing the user's input.
     */
    InteractionResponseType[InteractionResponseType["CHANNEL_MESSAGE_WITH_SOURCE"] = 4] = "CHANNEL_MESSAGE_WITH_SOURCE";
    /**
     * Acknowledge a command without sending a message, showing the user's input. Requires follow-up.
     */
    InteractionResponseType[InteractionResponseType["DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE"] = 5] = "DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE";
    /**
     * Acknowledge an interaction and edit the original message that contains the component later; the user does not see a loading state.
     */
    InteractionResponseType[InteractionResponseType["DEFERRED_UPDATE_MESSAGE"] = 6] = "DEFERRED_UPDATE_MESSAGE";
    /**
     * Edit the message the component was attached to.
     */
    InteractionResponseType[InteractionResponseType["UPDATE_MESSAGE"] = 7] = "UPDATE_MESSAGE";
    /*
     * Callback for an app to define the results to the user.
     */
    InteractionResponseType[InteractionResponseType["APPLICATION_COMMAND_AUTOCOMPLETE_RESULT"] = 8] = "APPLICATION_COMMAND_AUTOCOMPLETE_RESULT";
})(InteractionResponseType || (InteractionResponseType = {}));
exports.InteractionResponseType = InteractionResponseType;
/**
 * Flags that can be included in an Interaction Response.
 */
var InteractionResponseFlags;
(function (InteractionResponseFlags) {
    /**
     * Show the message only to the user that performed the interaction. Message
     * does not persist between sessions.
     */
    InteractionResponseFlags[InteractionResponseFlags["EPHEMERAL"] = 64] = "EPHEMERAL";
})(InteractionResponseFlags || (InteractionResponseFlags = {}));
exports.InteractionResponseFlags = InteractionResponseFlags;
/**
 * Converts different types to Uint8Array.
 *
 * @param value - Value to convert. Strings are parsed as hex.
 * @param format - Format of value. Valid options: 'hex'. Defaults to utf-8.
 * @returns Value in Uint8Array form.
 */
function valueToUint8Array(value, format) {
    if (value == null) {
        return new Uint8Array();
    }
    if (typeof value === 'string') {
        if (format === 'hex') {
            const matches = value.match(/.{1,2}/g);
            if (matches == null) {
                throw new Error('Value is not a valid hex string');
            }
            const hexVal = matches.map((byte) => parseInt(byte, 16));
            return new Uint8Array(hexVal);
        }
        else {
            return new LocalTextEncoder('utf-8').encode(value);
        }
    }
    try {
        if (Buffer.isBuffer(value)) {
            const arrayBuffer = value.buffer.slice(value.byteOffset, value.byteOffset + value.length);
            return new Uint8Array(value);
        }
    }
    catch (ex) {
        // Runtime doesn't have Buffer
    }
    if (value instanceof ArrayBuffer) {
        return new Uint8Array(value);
    }
    if (value instanceof Uint8Array) {
        return value;
    }
    throw new Error('Unrecognized value type, must be one of: string, Buffer, ArrayBuffer, Uint8Array');
}
/**
 * Merge two arrays.
 *
 * @param arr1 - First array
 * @param arr2 - Second array
 * @returns Concatenated arrays
 */
function concatUint8Arrays(arr1, arr2) {
    const merged = new Uint8Array(arr1.length + arr2.length);
    merged.set(arr1);
    merged.set(arr2, arr1.length);
    return merged;
}
/**
 * Validates a payload from Discord against its signature and key.
 *
 * @param rawBody - The raw payload data
 * @param signature - The signature from the `X-Signature-Ed25519` header
 * @param timestamp - The timestamp from the `X-Signature-Timestamp` header
 * @param clientPublicKey - The public key from the Discord developer dashboard
 * @returns Whether or not validation was successful
 */
function verifyKey(body, signature, timestamp, clientPublicKey) {
    try {
        const timestampData = valueToUint8Array(timestamp);
        const bodyData = valueToUint8Array(body);
        const message = concatUint8Arrays(timestampData, bodyData);
        const signatureData = valueToUint8Array(signature, 'hex');
        const publicKeyData = valueToUint8Array(clientPublicKey, 'hex');
        return nacl.sign.detached.verify(message, signatureData, publicKeyData);
    }
    catch (ex) {
        console.error('[discord-interactions]: Invalid verifyKey parameters', ex);
        return false;
    }
}
exports.verifyKey = verifyKey;
/**
 * Creates a middleware function for use in Express-compatible web servers.
 *
 * @param clientPublicKey - The public key from the Discord developer dashboard
 * @returns The middleware function
 */
function verifyKeyMiddleware(clientPublicKey) {
    if (!clientPublicKey) {
        throw new Error('You must specify a Discord client public key');
    }
    return function (req, res, next) {
        const timestamp = (req.header('X-Signature-Timestamp') || '');
        const signature = (req.header('X-Signature-Ed25519') || '');
        function onBodyComplete(rawBody) {
            if (!verifyKey(rawBody, signature, timestamp, clientPublicKey)) {
                res.statusCode = 401;
                res.end('[discord-interactions] Invalid signature');
                return;
            }
            const body = JSON.parse(rawBody.toString('utf-8')) || {};
            if (body.type === InteractionType.PING) {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify({
                    type: InteractionResponseType.PONG,
                }));
                return;
            }
            req.body = body;
            next();
        }
        if (req.body) {
            if (Buffer.isBuffer(req.body)) {
                onBodyComplete(req.body);
            }
            else if (typeof req.body === 'string') {
                onBodyComplete(Buffer.from(req.body, 'utf-8'));
            }
            else {
                console.warn('[discord-interactions]: req.body was tampered with, probably by some other middleware. We recommend disabling middleware for interaction routes so that req.body is a raw buffer.');
                // Attempt to reconstruct the raw buffer. This works but is risky
                // because it depends on JSON.stringify matching the Discord backend's
                // JSON serialization.
                onBodyComplete(Buffer.from(JSON.stringify(req.body), 'utf-8'));
            }
        }
        else {
            const chunks = [];
            req.on('data', (chunk) => {
                chunks.push(chunk);
            });
            req.on('end', () => {
                const rawBody = Buffer.concat(chunks);
                onBodyComplete(rawBody);
            });
        }
    };
}
exports.verifyKeyMiddleware = verifyKeyMiddleware;
//# sourceMappingURL=index.js.map